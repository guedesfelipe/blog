{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Felipe's Blog \u00b6 Eu sou o Felipe, prazer em conhec\u00ea-lo! \ud83d\udc4b Sou engenheiro de software Brasileiro . \ud83c\udde7\ud83c\uddf7 O blog tem como objetivo compartilhar conhecimento t\u00e9cnico em programa\u00e7\u00e3o que adquiri durante anos e aprendizados recentes, \u00e9 como se fosse meu bloco de notas um pouco mais refinado, mas com o mesmo teor t\u00e9cnico. Sempre tentando simplificar o entendimento. Sou criador do PLS-CLI . Se meu trabalho de c\u00f3digo aberto for \u00fatil para voc\u00ea, considere me comprar um caf\u00e9. \u2615\ufe0f Posts Recentes \u00b6 \u26a1\ufe0f Aumentando a performance dos conjuntos (sets) \u00b6 Felipe Guedes \u00b7 @guedesfelipe 09 Outubro, 2022 \u00b7 3 min leitura Voc\u00ea sabe como aumentar o desempenho dos conjuntos (sets)? Continue Lendo \ud83d\udee0 Python Disassembler \u00b6 Felipe Guedes \u00b7 @guedesfelipe 31 Agosto, 2022 \u00b7 1 min leitura Voc\u00ea sabe como disassemblar um c\u00f3digo python? Continue Lendo \ud83d\udd10 Segredos do arredondamento \u00b6 Felipe Guedes \u00b7 @guedesfelipe 23 Agosto, 2022 \u00b7 2 min leitura Voc\u00ea sabe como o round funciona no python por baixo dos panos? Eu tamb\u00e9m n\u00e3o sabia e achei interessante... Continue Lendo Como consumir uma API com Python \u00b6 Felipe Guedes \u00b7 @guedesfelipe 21 Abril, 2022 \u00b7 2 min leitura Para consumir uma API de forma simples com Python usaremos a biblioteca chamada requests... Continue Lendo","title":"\ud83c\udfe0 &nbsp;In\u00edcio"},{"location":"#felipes-blog","text":"Eu sou o Felipe, prazer em conhec\u00ea-lo! \ud83d\udc4b Sou engenheiro de software Brasileiro . \ud83c\udde7\ud83c\uddf7 O blog tem como objetivo compartilhar conhecimento t\u00e9cnico em programa\u00e7\u00e3o que adquiri durante anos e aprendizados recentes, \u00e9 como se fosse meu bloco de notas um pouco mais refinado, mas com o mesmo teor t\u00e9cnico. Sempre tentando simplificar o entendimento. Sou criador do PLS-CLI . Se meu trabalho de c\u00f3digo aberto for \u00fatil para voc\u00ea, considere me comprar um caf\u00e9. \u2615\ufe0f","title":"Felipe's Blog"},{"location":"#posts-recentes","text":"","title":"Posts Recentes"},{"location":"#aumentando-a-performance-dos-conjuntos-sets","text":"Felipe Guedes \u00b7 @guedesfelipe 09 Outubro, 2022 \u00b7 3 min leitura Voc\u00ea sabe como aumentar o desempenho dos conjuntos (sets)? Continue Lendo","title":"\u26a1\ufe0f Aumentando a performance dos conjuntos (sets)"},{"location":"#python-disassembler","text":"Felipe Guedes \u00b7 @guedesfelipe 31 Agosto, 2022 \u00b7 1 min leitura Voc\u00ea sabe como disassemblar um c\u00f3digo python? Continue Lendo","title":"\ud83d\udee0 Python Disassembler"},{"location":"#segredos-do-arredondamento","text":"Felipe Guedes \u00b7 @guedesfelipe 23 Agosto, 2022 \u00b7 2 min leitura Voc\u00ea sabe como o round funciona no python por baixo dos panos? Eu tamb\u00e9m n\u00e3o sabia e achei interessante... Continue Lendo","title":"\ud83d\udd10 Segredos do arredondamento"},{"location":"#como-consumir-uma-api-com-python","text":"Felipe Guedes \u00b7 @guedesfelipe 21 Abril, 2022 \u00b7 2 min leitura Para consumir uma API de forma simples com Python usaremos a biblioteca chamada requests... Continue Lendo","title":"Como consumir uma API com Python"},{"location":"python/consume-api/","text":"\ud83d\udc7d\ufe0f Como consumir uma API com Python \u00b6 Para consumir uma API de forma simples com Python usaremos a biblioteca chamada requests . \ud83d\udd27 Preparando o Ambiente \u00b6 Virtual Env Poetry python3 -m venv .venv # (1) source .venv/bin/activate # (2) pip install requests # (3) Criando a virtualenv ( Mude python3 para o PATH onde esta instalado o seu Python se for necess\u00e1rio) Ativando a virtualenv (MacOS e Linux) Instalando a biblioteca requests poetry add requests # (1) Instalando a biblioteca requests with Poetry \u2328\ufe0f C\u00f3digo \u00b6 Neste exemple vamos consumir a API que retornar\u00e1 um fato divertido aleat\u00f3rio e mostrar em tela. consume_api.py 1 2 3 4 5 6 7 8 9 10 import requests # (1) try : response = requests . get ( 'https://api.aakhilv.me/fun/facts' ) # (2) response . raise_for_status () # (3) fun_fact = response . json ()[ 0 ] # (4) print ( f 'Fun Fact: { fun_fact } ' ) # (5) except HTTPError as error : # (6) print ( f '[ { error . response . status_code } ] { error } ' ) # (7) Importando a biblioteca requests Realizando o get no enpoint /fun/facts na API Checando se a requisi\u00e7\u00e3o retornou algum erro de status_code , caso de erro ir\u00e1 gerar uma exce\u00e7\u00e3o do tipo HTTPError (Linha 9 trata esta exce\u00e7\u00e3o) Converte o response para json e pega o primeiro elemento da lista de retorno Mostra em tela um fato divertido aleat\u00f3rio Se a linha 6 levantar uma exce\u00e7\u00e3o do tipo HTTPError , aqui ela ser\u00e1 tratada Mostra em tela o status_code e o erro ocorrido \ud83d\ude80 Rodando a Aplica\u00e7\u00e3o \u00b6 python consume_api.py \ud83d\uddbc\ufe0f Sa\u00edda \u00b6","title":"\ud83d\udc7d\ufe0f Como consumir uma API com Python"},{"location":"python/consume-api/#como-consumir-uma-api-com-python","text":"Para consumir uma API de forma simples com Python usaremos a biblioteca chamada requests .","title":"\ud83d\udc7d\ufe0f Como consumir uma API com Python"},{"location":"python/consume-api/#preparando-o-ambiente","text":"Virtual Env Poetry python3 -m venv .venv # (1) source .venv/bin/activate # (2) pip install requests # (3) Criando a virtualenv ( Mude python3 para o PATH onde esta instalado o seu Python se for necess\u00e1rio) Ativando a virtualenv (MacOS e Linux) Instalando a biblioteca requests poetry add requests # (1) Instalando a biblioteca requests with Poetry","title":"\ud83d\udd27 Preparando o Ambiente"},{"location":"python/consume-api/#codigo","text":"Neste exemple vamos consumir a API que retornar\u00e1 um fato divertido aleat\u00f3rio e mostrar em tela. consume_api.py 1 2 3 4 5 6 7 8 9 10 import requests # (1) try : response = requests . get ( 'https://api.aakhilv.me/fun/facts' ) # (2) response . raise_for_status () # (3) fun_fact = response . json ()[ 0 ] # (4) print ( f 'Fun Fact: { fun_fact } ' ) # (5) except HTTPError as error : # (6) print ( f '[ { error . response . status_code } ] { error } ' ) # (7) Importando a biblioteca requests Realizando o get no enpoint /fun/facts na API Checando se a requisi\u00e7\u00e3o retornou algum erro de status_code , caso de erro ir\u00e1 gerar uma exce\u00e7\u00e3o do tipo HTTPError (Linha 9 trata esta exce\u00e7\u00e3o) Converte o response para json e pega o primeiro elemento da lista de retorno Mostra em tela um fato divertido aleat\u00f3rio Se a linha 6 levantar uma exce\u00e7\u00e3o do tipo HTTPError , aqui ela ser\u00e1 tratada Mostra em tela o status_code e o erro ocorrido","title":"\u2328\ufe0f C\u00f3digo"},{"location":"python/consume-api/#rodando-a-aplicacao","text":"python consume_api.py","title":"\ud83d\ude80 Rodando a Aplica\u00e7\u00e3o"},{"location":"python/consume-api/#saida","text":"","title":"\ud83d\uddbc\ufe0f Sa\u00edda"},{"location":"python/disassembler/","text":"\ud83d\udee0 Python Disassembler \u00b6 Essa dica \u00e9 para voc\u00ea que gosta de escovar bits e entender o que o python faz por baixo dos panos. Python possui um m\u00f3dulo que 'disassembla' seu c\u00f3digo, ou seja, voc\u00ea pode analisar o bytecode do seu c\u00f3digo! \u2697\ufe0f Teste \u00b6 Vamos testar, para isso precisamos importar o m\u00f3dulo chamado dis e utilizar conforme o exemplo abaixo: # >>>$ from dis import dis # >>>$ # >>>$ # >>>$ def add_two ( number: int ) -> int: # ...$ return number + 2 # >>>$ # >>>$ dis ( add_two ) 2 0 LOAD_FAST 0 (number) 2 LOAD_CONST 1 (2) 4 BINARY_ADD 6 RETURN_VALUE \ud83d\udd0e Explicando o resultado \u00b6 dis_example.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from dis import dis # (1) def add_two ( number : int ) -> int : # (2) return number + 2 dis ( add_two ) # (3) # Result # 2 0 LOAD_FAST 0 (number) (4) # 2 LOAD_CONST 1 (.2.) (5) # 4 BINARY_ADD (6) # 6 RETURN_VALUE (7) Importando a biblioteca dis . Declara uma fun\u00e7\u00e3o que adiciona dois a um n\u00famero. Chamando a fun\u00e7\u00e3o dis para disassemblar o c\u00f3digo e nos mostrar o bytecode. Envia uma refer\u00eancia para o local co_varnames[var_num] na pilha. Doc Link Coloca co_consts[consti] na pilha. Doc Link Implementa TOS = TOS1 + TOS . Doc Link Retorna com TOS para quem chamou a fun\u00e7\u00e3o. Doc Link \ud83d\udcd6 Documenta\u00e7\u00e3o Oficial \u00b6","title":"\ud83d\udee0 Python Disassembler"},{"location":"python/disassembler/#python-disassembler","text":"Essa dica \u00e9 para voc\u00ea que gosta de escovar bits e entender o que o python faz por baixo dos panos. Python possui um m\u00f3dulo que 'disassembla' seu c\u00f3digo, ou seja, voc\u00ea pode analisar o bytecode do seu c\u00f3digo!","title":"\ud83d\udee0 Python Disassembler"},{"location":"python/disassembler/#teste","text":"Vamos testar, para isso precisamos importar o m\u00f3dulo chamado dis e utilizar conforme o exemplo abaixo: # >>>$ from dis import dis # >>>$ # >>>$ # >>>$ def add_two ( number: int ) -> int: # ...$ return number + 2 # >>>$ # >>>$ dis ( add_two ) 2 0 LOAD_FAST 0 (number) 2 LOAD_CONST 1 (2) 4 BINARY_ADD 6 RETURN_VALUE","title":"\u2697\ufe0f Teste"},{"location":"python/disassembler/#explicando-o-resultado","text":"dis_example.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from dis import dis # (1) def add_two ( number : int ) -> int : # (2) return number + 2 dis ( add_two ) # (3) # Result # 2 0 LOAD_FAST 0 (number) (4) # 2 LOAD_CONST 1 (.2.) (5) # 4 BINARY_ADD (6) # 6 RETURN_VALUE (7) Importando a biblioteca dis . Declara uma fun\u00e7\u00e3o que adiciona dois a um n\u00famero. Chamando a fun\u00e7\u00e3o dis para disassemblar o c\u00f3digo e nos mostrar o bytecode. Envia uma refer\u00eancia para o local co_varnames[var_num] na pilha. Doc Link Coloca co_consts[consti] na pilha. Doc Link Implementa TOS = TOS1 + TOS . Doc Link Retorna com TOS para quem chamou a fun\u00e7\u00e3o. Doc Link","title":"\ud83d\udd0e Explicando o resultado"},{"location":"python/disassembler/#documentacao-oficial","text":"","title":"\ud83d\udcd6 Documenta\u00e7\u00e3o Oficial"},{"location":"python/increasing-performance-sets/","text":"\u26a1\ufe0f Aumentando a performance dos conjuntos (sets) \u00b6 Existe basicamente duas maneiras de declarar conjuntos(sets) no python: Primeira Op\u00e7\u00e3o primeira_opcao = { 1 , 2 } Segunda Op\u00e7\u00e3o segunda_opcao = set ([ 1 , 2 ]) Info Esta abordagem chama o construtor do conjunto(set) \ud83e\udd14 Mas qual a diferen\u00e7a entre eles? \u00b6 Vamos ver o que o Python faz por baixo dos panos usando disassembler . Vamos ver o byte code da primiera op\u00e7\u00e3o \u00b6 # >>>$ from dis import dis # >>>$ # >>>$ dis ( '{1, 2}' ) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 BUILD_SET 2 6 RETURN_VALUE Aqui podemos ver que quem faz quase todo o trabalho \u00e9 o byte_code especial chamado BUILD_SET e logo em seguida retorna o conjunto para n\u00f3s, muito simple n\u00e9? Vamos ver o byte code da segunda op\u00e7\u00e3o \u00b6 # >>>$ from dis import dis # >>>$ # >>>$ dis ( 'set([1, 2])' ) 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 LOAD_CONST 1 (2) 6 BUILD_LIST 2 8 CALL_FUNCTION 1 10 RETURN_VALUE Observe que ele faz muitas coisas que o primeiro n\u00e3o faz, isso torna essa abordagem mais lenta ao carregar conjuntos (sets) no python, pois no lugar do BUILD_SET ele precisa fazer mais 3 passos, que s\u00e3o LOAD_NAME , BUILD_LIST e CALL_FUNCTION . Essa forma \u00e9 mais lenta porque o interpretador python precisa pesquisar o nome do conjunto (set) para encontrar o construtor, criar uma lista e, finalmente, pass\u00e1-la para o construtor. Voc\u00ea pode encontrar a descri\u00e7\u00e3o de todos os byte codes aqui . \ud83d\udcc8 Benchmark \u00b6 Na tabela abiaxo podemos ver a diferen\u00e7a entre as duas maneiras e qual \u00e9 a mais otimizada: Set Size Factor Constructor Time/s Factor Without Constructor Time/s Factor % Optimization 1.000 1x 0.0000577s 1.00x 0.0000435s 1.00x 24.61% 10.000 10x 0.0006500s 11.27x 0.0005280s 12.14x 18.77% 100.000 100x 0.0097000s 168.11x 0.0094400s 217.01x 2.68% 1.000.000 1.000x 0.1050000s 1819.76x 0.1000000s 2298.85x 4.76% 10.000.000 10.000x 1.1200000s 19410.75x 0.8950000s 20574.71x 18.75% Note Laptop Core i5-4278U 2.60GHz executing in python 3.9.10 Example - Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit 'set([num for num in range(10**3)])' 5000 loops, best of 5: 57.7 usec per loop $ python -m timeit 'set([num for num in range(10**4)])' 500 loops, best of 5: 650 usec per loop $ python -m timeit 'set([num for num in range(10**5)])' 50 loops, best of 5: 9.7 msec per loop $ python -m timeit 'set([num for num in range(10**6)])' 2 loops, best of 5: 105 msec per loop $ python -m timeit 'set([num for num in range(10**7)])' 1 loops, best of 5: 1.12 sec per loop Example - Whithout Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit '{num for num in range(10**3)}' 5000 loops, best of 5: 43.5 usec per loop $ python -m timeit '{num for num in range(10**4)}' 500 loops, best of 5: 528 usec per loop $ python -m timeit '{num for num in range(10**5)}' 50 loops, best of 5: 9.44 msec per loop $ python -m timeit '{num for num in range(10**6)}' 2 loops, best of 5: 100 msec per loop $ python -m timeit '{num for num in range(10**7)}' 1 loops, best of 5: 895 msec per loop Conclus\u00e3o \u00b6 Ent\u00e3o, se um dia voc\u00ea precisar instanciar um conjunto (set), tente sempre usar a primeira op\u00e7\u00e3o, pois ela \u00e9 mais otimizada. E uma dica extra: Caso precise instanciar um conjunto (set) vazio, s\u00f3 podemos fazer isso chamando o construtor, ok?! Deixe seu coment\u00e1rio abaixo sobre o post, at\u00e9 a pr\u00f3xima! \ud83d\ude03","title":"\u26a1\ufe0f Aumentando a performance dos conjuntos (sets)"},{"location":"python/increasing-performance-sets/#aumentando-a-performance-dos-conjuntos-sets","text":"Existe basicamente duas maneiras de declarar conjuntos(sets) no python: Primeira Op\u00e7\u00e3o primeira_opcao = { 1 , 2 } Segunda Op\u00e7\u00e3o segunda_opcao = set ([ 1 , 2 ]) Info Esta abordagem chama o construtor do conjunto(set)","title":"\u26a1\ufe0f Aumentando a performance dos conjuntos (sets)"},{"location":"python/increasing-performance-sets/#mas-qual-a-diferenca-entre-eles","text":"Vamos ver o que o Python faz por baixo dos panos usando disassembler .","title":"\ud83e\udd14 Mas qual a diferen\u00e7a entre eles?"},{"location":"python/increasing-performance-sets/#vamos-ver-o-byte-code-da-primiera-opcao","text":"# >>>$ from dis import dis # >>>$ # >>>$ dis ( '{1, 2}' ) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 BUILD_SET 2 6 RETURN_VALUE Aqui podemos ver que quem faz quase todo o trabalho \u00e9 o byte_code especial chamado BUILD_SET e logo em seguida retorna o conjunto para n\u00f3s, muito simple n\u00e9?","title":"Vamos ver o byte code da primiera op\u00e7\u00e3o"},{"location":"python/increasing-performance-sets/#vamos-ver-o-byte-code-da-segunda-opcao","text":"# >>>$ from dis import dis # >>>$ # >>>$ dis ( 'set([1, 2])' ) 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 LOAD_CONST 1 (2) 6 BUILD_LIST 2 8 CALL_FUNCTION 1 10 RETURN_VALUE Observe que ele faz muitas coisas que o primeiro n\u00e3o faz, isso torna essa abordagem mais lenta ao carregar conjuntos (sets) no python, pois no lugar do BUILD_SET ele precisa fazer mais 3 passos, que s\u00e3o LOAD_NAME , BUILD_LIST e CALL_FUNCTION . Essa forma \u00e9 mais lenta porque o interpretador python precisa pesquisar o nome do conjunto (set) para encontrar o construtor, criar uma lista e, finalmente, pass\u00e1-la para o construtor. Voc\u00ea pode encontrar a descri\u00e7\u00e3o de todos os byte codes aqui .","title":"Vamos ver o byte code da segunda op\u00e7\u00e3o"},{"location":"python/increasing-performance-sets/#benchmark","text":"Na tabela abiaxo podemos ver a diferen\u00e7a entre as duas maneiras e qual \u00e9 a mais otimizada: Set Size Factor Constructor Time/s Factor Without Constructor Time/s Factor % Optimization 1.000 1x 0.0000577s 1.00x 0.0000435s 1.00x 24.61% 10.000 10x 0.0006500s 11.27x 0.0005280s 12.14x 18.77% 100.000 100x 0.0097000s 168.11x 0.0094400s 217.01x 2.68% 1.000.000 1.000x 0.1050000s 1819.76x 0.1000000s 2298.85x 4.76% 10.000.000 10.000x 1.1200000s 19410.75x 0.8950000s 20574.71x 18.75% Note Laptop Core i5-4278U 2.60GHz executing in python 3.9.10 Example - Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit 'set([num for num in range(10**3)])' 5000 loops, best of 5: 57.7 usec per loop $ python -m timeit 'set([num for num in range(10**4)])' 500 loops, best of 5: 650 usec per loop $ python -m timeit 'set([num for num in range(10**5)])' 50 loops, best of 5: 9.7 msec per loop $ python -m timeit 'set([num for num in range(10**6)])' 2 loops, best of 5: 105 msec per loop $ python -m timeit 'set([num for num in range(10**7)])' 1 loops, best of 5: 1.12 sec per loop Example - Whithout Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit '{num for num in range(10**3)}' 5000 loops, best of 5: 43.5 usec per loop $ python -m timeit '{num for num in range(10**4)}' 500 loops, best of 5: 528 usec per loop $ python -m timeit '{num for num in range(10**5)}' 50 loops, best of 5: 9.44 msec per loop $ python -m timeit '{num for num in range(10**6)}' 2 loops, best of 5: 100 msec per loop $ python -m timeit '{num for num in range(10**7)}' 1 loops, best of 5: 895 msec per loop","title":"\ud83d\udcc8 Benchmark"},{"location":"python/increasing-performance-sets/#conclusao","text":"Ent\u00e3o, se um dia voc\u00ea precisar instanciar um conjunto (set), tente sempre usar a primeira op\u00e7\u00e3o, pois ela \u00e9 mais otimizada. E uma dica extra: Caso precise instanciar um conjunto (set) vazio, s\u00f3 podemos fazer isso chamando o construtor, ok?! Deixe seu coment\u00e1rio abaixo sobre o post, at\u00e9 a pr\u00f3xima! \ud83d\ude03","title":"Conclus\u00e3o"},{"location":"python/rounding-secret/","text":"\ud83d\udd10 Segredos do arredondamento \u00b6 Voc\u00ea sabe como o round funciona no python por baixo dos panos? Eu tamb\u00e9m n\u00e3o sabia e achei interessante. Vamos fazer alguns experimentos com o round com alguns c\u00e1lculos: \\(\\frac{7}{2}=\\lfloor{3.5}\\rceil\\implies4\\) \u00b6 Exemplo no Python # >>>$ round ( 7 /2 ) 4 \\(\\frac{3}{2}=\\lfloor{1.5}\\rceil\\implies2\\) \u00b6 Exemplo no Python # >>>$ round ( 3 /2 ) 2 \\(\\frac{9}{2}=\\lfloor{4.5}\\rceil\\implies5\\) \u00b6 # >>>$ round ( 9 /2 ) 4 Aten\u00e7\u00e3o Porque o python n\u00e3o arredondou para 5? \\(\\frac{5}{2}=\\lfloor{2.5}\\rceil\\implies3\\) \u00b6 # >>>$ round ( 5 /2 ) 2 Aten\u00e7\u00e3o Porque o python n\u00e3o arredondou para 3? Por qu\u00ea? \u00b6 Um pouco fora do esperado estes resultados n\u00e9? Mas tudo tem uma raz\u00e3o Isso ocorre porque, em Python, a fun\u00e7\u00e3o round \u00e9 implementada com o arredondamento banc\u00e1rio , onde todos os valores da metade s\u00e3o arredondados para o n\u00famero par mais pr\u00f3ximo. IEEE 754 recomenda usar este arredondamento. Info Institute of Electrical and Electronics Engineers - ( IEEE ) Documenta\u00e7\u00e3o Python Round Cita\u00e7\u00e3o original em Inlg\u00eas round(number[, ndigits]) \u00b6 Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None , it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits ; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None . Otherwise, the return value has the same type as number . For a general Python object number , round delegates to number.__round__ . Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 . This is not a bug: it\u2019s a result of the fact that most decimal fractions can\u2019t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. Ap\u00f3s saber disto nunca mais usarei o round da mesma forma. Leitura Recomendada (EN): Is bankers rounding really more numerically stable?","title":"\ud83d\udd10 Segredos do arredondamento"},{"location":"python/rounding-secret/#segredos-do-arredondamento","text":"Voc\u00ea sabe como o round funciona no python por baixo dos panos? Eu tamb\u00e9m n\u00e3o sabia e achei interessante. Vamos fazer alguns experimentos com o round com alguns c\u00e1lculos:","title":"\ud83d\udd10 Segredos do arredondamento"},{"location":"python/rounding-secret/#frac72lfloor35rceilimplies4","text":"Exemplo no Python # >>>$ round ( 7 /2 ) 4","title":"\\(\\frac{7}{2}=\\lfloor{3.5}\\rceil\\implies4\\)"},{"location":"python/rounding-secret/#frac32lfloor15rceilimplies2","text":"Exemplo no Python # >>>$ round ( 3 /2 ) 2","title":"\\(\\frac{3}{2}=\\lfloor{1.5}\\rceil\\implies2\\)"},{"location":"python/rounding-secret/#frac92lfloor45rceilimplies5","text":"# >>>$ round ( 9 /2 ) 4 Aten\u00e7\u00e3o Porque o python n\u00e3o arredondou para 5?","title":"\\(\\frac{9}{2}=\\lfloor{4.5}\\rceil\\implies5\\)"},{"location":"python/rounding-secret/#frac52lfloor25rceilimplies3","text":"# >>>$ round ( 5 /2 ) 2 Aten\u00e7\u00e3o Porque o python n\u00e3o arredondou para 3?","title":"\\(\\frac{5}{2}=\\lfloor{2.5}\\rceil\\implies3\\)"},{"location":"python/rounding-secret/#por-que","text":"Um pouco fora do esperado estes resultados n\u00e9? Mas tudo tem uma raz\u00e3o Isso ocorre porque, em Python, a fun\u00e7\u00e3o round \u00e9 implementada com o arredondamento banc\u00e1rio , onde todos os valores da metade s\u00e3o arredondados para o n\u00famero par mais pr\u00f3ximo. IEEE 754 recomenda usar este arredondamento. Info Institute of Electrical and Electronics Engineers - ( IEEE )","title":"Por qu\u00ea?"},{"location":"python/rounding-secret/#roundnumber-ndigits","text":"Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None , it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits ; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None . Otherwise, the return value has the same type as number . For a general Python object number , round delegates to number.__round__ . Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 . This is not a bug: it\u2019s a result of the fact that most decimal fractions can\u2019t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. Ap\u00f3s saber disto nunca mais usarei o round da mesma forma. Leitura Recomendada (EN): Is bankers rounding really more numerically stable?","title":"round(number[, ndigits])"}]}