{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Felipe's Blog \u00b6 I'm Felipe, nice to meet you! \ud83d\udc4b I'm a software engineer from Brazil . \ud83c\udde7\ud83c\uddf7 The blog aims to share technical knowledge in programming that I acquired during years and recent learnings, it's like my notebook a little more refined, but with the same technical content. Always trying to simplify understanding. I'm the creator of PLS-CLI . If my open source work is useful to you, consider buying me a coffee. \u2615\ufe0f Recent Posts \u00b6 \u26a1\ufe0f Increasing the performance of sets \u00b6 Felipe Guedes \u00b7 @guedesfelipe October 09, 2022 \u00b7 3 min read Do you know how Increasing the performance of sets? Continue reading \ud83d\udee0 Python Disassembler \u00b6 Felipe Guedes \u00b7 @guedesfelipe August 31, 2022 \u00b7 1 min read Do you know how disassembly python code? Continue reading \ud83d\udd10 Rounding Secret \u00b6 Felipe Guedes \u00b7 @guedesfelipe August 23, 2022 \u00b7 2 min read Do you know how round works in python under the hood? I didn't know either and I thought it was interesting... Continue reading How to consume an API with Python \u00b6 Felipe Guedes \u00b7 @guedesfelipe April 21, 2022 \u00b7 2 min read To consume an API in a simple way with python we will use the library called requests... Continue reading","title":"\ud83c\udfe0 &nbsp;Home"},{"location":"#felipes-blog","text":"I'm Felipe, nice to meet you! \ud83d\udc4b I'm a software engineer from Brazil . \ud83c\udde7\ud83c\uddf7 The blog aims to share technical knowledge in programming that I acquired during years and recent learnings, it's like my notebook a little more refined, but with the same technical content. Always trying to simplify understanding. I'm the creator of PLS-CLI . If my open source work is useful to you, consider buying me a coffee. \u2615\ufe0f","title":"Felipe's Blog"},{"location":"#recent-posts","text":"","title":"Recent Posts"},{"location":"#increasing-the-performance-of-sets","text":"Felipe Guedes \u00b7 @guedesfelipe October 09, 2022 \u00b7 3 min read Do you know how Increasing the performance of sets? Continue reading","title":"\u26a1\ufe0f Increasing the performance of sets"},{"location":"#python-disassembler","text":"Felipe Guedes \u00b7 @guedesfelipe August 31, 2022 \u00b7 1 min read Do you know how disassembly python code? Continue reading","title":"\ud83d\udee0 Python Disassembler"},{"location":"#rounding-secret","text":"Felipe Guedes \u00b7 @guedesfelipe August 23, 2022 \u00b7 2 min read Do you know how round works in python under the hood? I didn't know either and I thought it was interesting... Continue reading","title":"\ud83d\udd10 Rounding Secret"},{"location":"#how-to-consume-an-api-with-python","text":"Felipe Guedes \u00b7 @guedesfelipe April 21, 2022 \u00b7 2 min read To consume an API in a simple way with python we will use the library called requests... Continue reading","title":"How to consume an API with Python"},{"location":"python/consume-api/","text":"\ud83d\udc7d\ufe0f How to consume an API with Python \u00b6 To consume an API in a simple way with python we will use the library called requests . \ud83d\udd27 Preparing the Environment \u00b6 Virtual Env Poetry python3 -m venv .venv # (1) source .venv/bin/activate # (2) pip install requests # (3) Creating a virtualenv ( Change python3 to your python PATH if necessary) Activate the virtualenv (MacOS and Linux) Install requests poetry add requests # (1) Install requests with Poetry \u2328\ufe0f Code \u00b6 In this example we are going to consume an API that will return random fun facts and print it on screen. consume_api.py 1 2 3 4 5 6 7 8 9 10 import requests # (1) try : response = requests . get ( 'https://api.aakhilv.me/fun/facts' ) # (2) response . raise_for_status () # (3) fun_fact = response . json ()[ 0 ] # (4) print ( f 'Fun Fact: { fun_fact } ' ) # (5) except HTTPError as error : # (6) print ( f '[ { error . response . status_code } ] { error } ' ) # (7) Importing the requests library Performing the get on endpoint /fun/facts in the API Checking if the request returned any error status_code , in case of error it will generate an exception of type HTTPError (Line 9 handle this) Convert response to json and get first element from the return list Print on screen the random fun fact If line 6 raise an HTTPError exception, here it will be handled Print status_code information and the error \ud83d\ude80 Running the Application \u00b6 python consume_api.py \ud83d\uddbc\ufe0f Output \u00b6","title":"\ud83d\udc7d\ufe0f How to consume an API with Python"},{"location":"python/consume-api/#how-to-consume-an-api-with-python","text":"To consume an API in a simple way with python we will use the library called requests .","title":"\ud83d\udc7d\ufe0f How to consume an API with Python"},{"location":"python/consume-api/#preparing-the-environment","text":"Virtual Env Poetry python3 -m venv .venv # (1) source .venv/bin/activate # (2) pip install requests # (3) Creating a virtualenv ( Change python3 to your python PATH if necessary) Activate the virtualenv (MacOS and Linux) Install requests poetry add requests # (1) Install requests with Poetry","title":"\ud83d\udd27 Preparing the Environment"},{"location":"python/consume-api/#code","text":"In this example we are going to consume an API that will return random fun facts and print it on screen. consume_api.py 1 2 3 4 5 6 7 8 9 10 import requests # (1) try : response = requests . get ( 'https://api.aakhilv.me/fun/facts' ) # (2) response . raise_for_status () # (3) fun_fact = response . json ()[ 0 ] # (4) print ( f 'Fun Fact: { fun_fact } ' ) # (5) except HTTPError as error : # (6) print ( f '[ { error . response . status_code } ] { error } ' ) # (7) Importing the requests library Performing the get on endpoint /fun/facts in the API Checking if the request returned any error status_code , in case of error it will generate an exception of type HTTPError (Line 9 handle this) Convert response to json and get first element from the return list Print on screen the random fun fact If line 6 raise an HTTPError exception, here it will be handled Print status_code information and the error","title":"\u2328\ufe0f Code"},{"location":"python/consume-api/#running-the-application","text":"python consume_api.py","title":"\ud83d\ude80 Running the Application"},{"location":"python/consume-api/#output","text":"","title":"\ud83d\uddbc\ufe0f Output"},{"location":"python/disassembler/","text":"\ud83d\udee0 Python Disassembler \u00b6 This tip is for you who like to bit diddling and understand what python does under the hood. Python has a module that disassembles your code, that is, you can analyze the bytecode of your code! \u2697\ufe0f Test \u00b6 Let's test it, for that we need to import the module called dis and use it as shown in the example below:: # >>>$ from dis import dis # >>>$ # >>>$ # >>>$ def add_two ( number: int ) -> int: # ...$ return number + 2 # >>>$ # >>>$ dis ( add_two ) 2 0 LOAD_FAST 0 (number) 2 LOAD_CONST 1 (2) 4 BINARY_ADD 6 RETURN_VALUE \ud83d\udd0e Explaining the result \u00b6 dis_example.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from dis import dis # (1) def add_two ( number : int ) -> int : # (2) return number + 2 dis ( add_two ) # (3) # Result # 2 0 LOAD_FAST 0 (number) (4) # 2 LOAD_CONST 1 (.2.) (5) # 4 BINARY_ADD (6) # 6 RETURN_VALUE (7) Importing dis library. Declare a function that adds two to a number. Calling Disassembly function to show us the bytecode. Pushes a reference to the local co_varnames[var_num] onto the stack. Doc Link Pushes co_consts[consti] onto the stack. Doc Link Implements TOS = TOS1 + TOS . Doc Link Returns with TOS to the caller of the function. Doc Link \ud83d\udcd6 Official Documentation \u00b6","title":"\ud83d\udee0 Python Disassembler"},{"location":"python/disassembler/#python-disassembler","text":"This tip is for you who like to bit diddling and understand what python does under the hood. Python has a module that disassembles your code, that is, you can analyze the bytecode of your code!","title":"\ud83d\udee0 Python Disassembler"},{"location":"python/disassembler/#test","text":"Let's test it, for that we need to import the module called dis and use it as shown in the example below:: # >>>$ from dis import dis # >>>$ # >>>$ # >>>$ def add_two ( number: int ) -> int: # ...$ return number + 2 # >>>$ # >>>$ dis ( add_two ) 2 0 LOAD_FAST 0 (number) 2 LOAD_CONST 1 (2) 4 BINARY_ADD 6 RETURN_VALUE","title":"\u2697\ufe0f Test"},{"location":"python/disassembler/#explaining-the-result","text":"dis_example.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from dis import dis # (1) def add_two ( number : int ) -> int : # (2) return number + 2 dis ( add_two ) # (3) # Result # 2 0 LOAD_FAST 0 (number) (4) # 2 LOAD_CONST 1 (.2.) (5) # 4 BINARY_ADD (6) # 6 RETURN_VALUE (7) Importing dis library. Declare a function that adds two to a number. Calling Disassembly function to show us the bytecode. Pushes a reference to the local co_varnames[var_num] onto the stack. Doc Link Pushes co_consts[consti] onto the stack. Doc Link Implements TOS = TOS1 + TOS . Doc Link Returns with TOS to the caller of the function. Doc Link","title":"\ud83d\udd0e Explaining the result"},{"location":"python/disassembler/#official-documentation","text":"","title":"\ud83d\udcd6 Official Documentation"},{"location":"python/increasing-performance-sets/","text":"\u26a1\ufe0f Increasing the performance of sets \u00b6 There are basically two ways to declare sets in python: First Option first_option = { 1 , 2 } Second Option second_option = set ([ 1 , 2 ]) Info This aproach calls the constructor of sets \ud83e\udd14 But what is the difference between them? \u00b6 Let's see what python does under the hood using disassembler . Let's see the byte code of the first option \u00b6 # >>>$ from dis import dis # >>>$ # >>>$ dis ( '{1, 2}' ) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 BUILD_SET 2 6 RETURN_VALUE Here we can see that whoever does almost all the work is the special byte_code called BUILD_SET and soon after it returns the set to us. Very simple, right? Let's see the byte code of the second option \u00b6 # >>>$ from dis import dis # >>>$ # >>>$ dis ( 'set([1, 2])' ) 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 LOAD_CONST 1 (2) 6 BUILD_LIST 2 8 CALL_FUNCTION 1 10 RETURN_VALUE Notice that it does a lot of things that the first one doesn't, this makes this approach slower when loading sets in python, because instead of BUILD_SET it needs to do 3 more steps, which are LOAD_NAME , BUILD_LIST and CALL_FUNCTION . This way is slower because the python interpreter needs to look up the set name to find the constructor, then build a list and finally pass it to the constructor. You can find the description of all byte codes here . \ud83d\udcc8 Benchmark \u00b6 In the table below, we can see the difference between the two way, and which one is more optimized: Set Size Factor Constructor Time/s Factor Without Constructor Time/s Factor % Optimization 1.000 1x 0.0000577s 1.00x 0.0000435s 1.00x 24.61% 10.000 10x 0.0006500s 11.27x 0.0005280s 12.14x 18.77% 100.000 100x 0.0097000s 168.11x 0.0094400s 217.01x 2.68% 1.000.000 1.000x 0.1050000s 1819.76x 0.1000000s 2298.85x 4.76% 10.000.000 10.000x 1.1200000s 19410.75x 0.8950000s 20574.71x 18.75% Note Laptop Core i5-4278U 2.60GHz executing in python 3.9.10 Example - Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit 'set([num for num in range(10**3)])' 5000 loops, best of 5: 57.7 usec per loop $ python -m timeit 'set([num for num in range(10**4)])' 500 loops, best of 5: 650 usec per loop $ python -m timeit 'set([num for num in range(10**5)])' 50 loops, best of 5: 9.7 msec per loop $ python -m timeit 'set([num for num in range(10**6)])' 2 loops, best of 5: 105 msec per loop $ python -m timeit 'set([num for num in range(10**7)])' 1 loops, best of 5: 1.12 sec per loop Example - Whithout Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit '{num for num in range(10**3)}' 5000 loops, best of 5: 43.5 usec per loop $ python -m timeit '{num for num in range(10**4)}' 500 loops, best of 5: 528 usec per loop $ python -m timeit '{num for num in range(10**5)}' 50 loops, best of 5: 9.44 msec per loop $ python -m timeit '{num for num in range(10**6)}' 2 loops, best of 5: 100 msec per loop $ python -m timeit '{num for num in range(10**7)}' 1 loops, best of 5: 895 msec per loop Conclusion \u00b6 So if one day you need to instantiate a set, always try to use the first option, because it is more optimized. And an extra tip: In case you need to instantiate an empty set, we can only do that by calling the constructor, okay?! Leave your comment below about the post, see you next time! \ud83d\ude03","title":"\u26a1\ufe0f Increasing the performance of sets"},{"location":"python/increasing-performance-sets/#increasing-the-performance-of-sets","text":"There are basically two ways to declare sets in python: First Option first_option = { 1 , 2 } Second Option second_option = set ([ 1 , 2 ]) Info This aproach calls the constructor of sets","title":"\u26a1\ufe0f Increasing the performance of sets"},{"location":"python/increasing-performance-sets/#but-what-is-the-difference-between-them","text":"Let's see what python does under the hood using disassembler .","title":"\ud83e\udd14 But what is the difference between them?"},{"location":"python/increasing-performance-sets/#lets-see-the-byte-code-of-the-first-option","text":"# >>>$ from dis import dis # >>>$ # >>>$ dis ( '{1, 2}' ) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 BUILD_SET 2 6 RETURN_VALUE Here we can see that whoever does almost all the work is the special byte_code called BUILD_SET and soon after it returns the set to us. Very simple, right?","title":"Let's see the byte code of the first option"},{"location":"python/increasing-performance-sets/#lets-see-the-byte-code-of-the-second-option","text":"# >>>$ from dis import dis # >>>$ # >>>$ dis ( 'set([1, 2])' ) 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 LOAD_CONST 1 (2) 6 BUILD_LIST 2 8 CALL_FUNCTION 1 10 RETURN_VALUE Notice that it does a lot of things that the first one doesn't, this makes this approach slower when loading sets in python, because instead of BUILD_SET it needs to do 3 more steps, which are LOAD_NAME , BUILD_LIST and CALL_FUNCTION . This way is slower because the python interpreter needs to look up the set name to find the constructor, then build a list and finally pass it to the constructor. You can find the description of all byte codes here .","title":"Let's see the byte code of the second option"},{"location":"python/increasing-performance-sets/#benchmark","text":"In the table below, we can see the difference between the two way, and which one is more optimized: Set Size Factor Constructor Time/s Factor Without Constructor Time/s Factor % Optimization 1.000 1x 0.0000577s 1.00x 0.0000435s 1.00x 24.61% 10.000 10x 0.0006500s 11.27x 0.0005280s 12.14x 18.77% 100.000 100x 0.0097000s 168.11x 0.0094400s 217.01x 2.68% 1.000.000 1.000x 0.1050000s 1819.76x 0.1000000s 2298.85x 4.76% 10.000.000 10.000x 1.1200000s 19410.75x 0.8950000s 20574.71x 18.75% Note Laptop Core i5-4278U 2.60GHz executing in python 3.9.10 Example - Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit 'set([num for num in range(10**3)])' 5000 loops, best of 5: 57.7 usec per loop $ python -m timeit 'set([num for num in range(10**4)])' 500 loops, best of 5: 650 usec per loop $ python -m timeit 'set([num for num in range(10**5)])' 50 loops, best of 5: 9.7 msec per loop $ python -m timeit 'set([num for num in range(10**6)])' 2 loops, best of 5: 105 msec per loop $ python -m timeit 'set([num for num in range(10**7)])' 1 loops, best of 5: 1.12 sec per loop Example - Whithout Constructor Time 1.000 10.000 100.000 1.000.000 10.000.000 $ python -m timeit '{num for num in range(10**3)}' 5000 loops, best of 5: 43.5 usec per loop $ python -m timeit '{num for num in range(10**4)}' 500 loops, best of 5: 528 usec per loop $ python -m timeit '{num for num in range(10**5)}' 50 loops, best of 5: 9.44 msec per loop $ python -m timeit '{num for num in range(10**6)}' 2 loops, best of 5: 100 msec per loop $ python -m timeit '{num for num in range(10**7)}' 1 loops, best of 5: 895 msec per loop","title":"\ud83d\udcc8 Benchmark"},{"location":"python/increasing-performance-sets/#conclusion","text":"So if one day you need to instantiate a set, always try to use the first option, because it is more optimized. And an extra tip: In case you need to instantiate an empty set, we can only do that by calling the constructor, okay?! Leave your comment below about the post, see you next time! \ud83d\ude03","title":"Conclusion"},{"location":"python/rounding-secret/","text":"\ud83d\udd10 Rounding Secret \u00b6 Do you know how round works in python under the hood? I didn't know either and I thought it was interesting. Let's do some experiments with the round with some calcs: \\(\\frac{7}{2}=\\lfloor{3.5}\\rceil\\implies4\\) \u00b6 Python Example # >>>$ round ( 7 /2 ) 4 \\(\\frac{3}{2}=\\lfloor{1.5}\\rceil\\implies2\\) \u00b6 Python Example # >>>$ round ( 3 /2 ) 2 \\(\\frac{9}{2}=\\lfloor{4.5}\\rceil\\implies5\\) \u00b6 # >>>$ round ( 9 /2 ) 4 Attention Why python doesn't round to 5? \\(\\frac{5}{2}=\\lfloor{2.5}\\rceil\\implies3\\) \u00b6 # >>>$ round ( 5 /2 ) 2 Attention Why python doesn't round to 3? Why? \u00b6 This Result was not expected, right? But everything has a reason This is because, in Python, the round function implements banker's rounding , where all the half values are rounded to the closest even number. IEEE 754 recommends using this rounding. Info Institute of Electrical and Electronics Engineers - ( IEEE ) Round Python Docs Quote round(number[, ndigits]) \u00b6 Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None , it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits ; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None . Otherwise, the return value has the same type as number . For a general Python object number , round delegates to number.__round__ . Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 . This is not a bug: it\u2019s a result of the fact that most decimal fractions can\u2019t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. After knowing this I'll never use the round in the same way again. Recommended reading: Is bankers rounding really more numerically stable?","title":"\ud83d\udd10 Rounding Secret"},{"location":"python/rounding-secret/#rounding-secret","text":"Do you know how round works in python under the hood? I didn't know either and I thought it was interesting. Let's do some experiments with the round with some calcs:","title":"\ud83d\udd10 Rounding Secret"},{"location":"python/rounding-secret/#frac72lfloor35rceilimplies4","text":"Python Example # >>>$ round ( 7 /2 ) 4","title":"\\(\\frac{7}{2}=\\lfloor{3.5}\\rceil\\implies4\\)"},{"location":"python/rounding-secret/#frac32lfloor15rceilimplies2","text":"Python Example # >>>$ round ( 3 /2 ) 2","title":"\\(\\frac{3}{2}=\\lfloor{1.5}\\rceil\\implies2\\)"},{"location":"python/rounding-secret/#frac92lfloor45rceilimplies5","text":"# >>>$ round ( 9 /2 ) 4 Attention Why python doesn't round to 5?","title":"\\(\\frac{9}{2}=\\lfloor{4.5}\\rceil\\implies5\\)"},{"location":"python/rounding-secret/#frac52lfloor25rceilimplies3","text":"# >>>$ round ( 5 /2 ) 2 Attention Why python doesn't round to 3?","title":"\\(\\frac{5}{2}=\\lfloor{2.5}\\rceil\\implies3\\)"},{"location":"python/rounding-secret/#why","text":"This Result was not expected, right? But everything has a reason This is because, in Python, the round function implements banker's rounding , where all the half values are rounded to the closest even number. IEEE 754 recommends using this rounding. Info Institute of Electrical and Electronics Engineers - ( IEEE )","title":"Why?"},{"location":"python/rounding-secret/#roundnumber-ndigits","text":"Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None , it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits ; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None . Otherwise, the return value has the same type as number . For a general Python object number , round delegates to number.__round__ . Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 . This is not a bug: it\u2019s a result of the fact that most decimal fractions can\u2019t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information. After knowing this I'll never use the round in the same way again. Recommended reading: Is bankers rounding really more numerically stable?","title":"round(number[, ndigits])"}]}